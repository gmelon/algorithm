# 다이나믹 프로그래밍 이론

## 조건
* 큰 문제를 작은 문제로 나눌 수 있다
* 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다

-> 주로 점화식을 사용해 문제 풀이 방법을 만들 수 있음

## 탑다운
* 가장 큰 문제의 해답을 찾기위해 큰 문제를 구성하는 작은 문제들을 차례대로 호출하며 풀어나가는 방식
* 재귀 + 메모이제이션을 사용해 구현됨

```java
// 피보나치
static int[] dp = new int[N];

public void fibo(x) {
	if(x == 1 || x == 2) {
		return 1;
	}
	
	// 메모이제이션
	if (dp[x] != 0) {
		return dp[x];
	}

	dp[x] = fibo(x - 1) + fibo(x - 2);
	return dp[x];
}
```

## 바텀업
* 가장 작은 문제에서 시작해, 최종적으로 풀고자 하는 문제까지 차례대로 풀어나가는 방식

```java
static int[] dp = new int[N];

dp[1] = 1;
dp[2] = 1;

// fibo(x) 를 계산하고자 할 떄
for (int i = 3 ; i <= x ; i++) {
	dp[i] = dp[i - 1] + dp[i - 2];
}
```

